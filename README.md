CodeLibrary
===========

A storage for the most commonly used algorithms and data structures. 

Please note that we are currently working to make this library as usefull as possible by
adding kind of readme file to every code, which contains important pieces of information
such as detailed instructions how to use it, what is the input/output and some significant assumptions we made
during the process of implementation. We are also providing information about the problems (usually from SPOJ.com) 
solved by explicit or implicit (i.e some easy modification) useage of a particular algo. 

You may consider it as a spoiler in some case, so be aware that our intention is to deliver you a confirmation of correctness of a particular implementation, not a detailed solution.

However in early development some of the codes may be flaged as [UNTESTED] just to inform you, that they might have a nonzero probability of failing in some cases :-) Still we are doing our best to avoid that uncertainity.  

Table of contents:
===========

###Graph algorithms
<ol>
<li>Breadth First Search</li>
<li>Breadth First Search on grid</li>

<li>Depth First Search</li>
<li>Depth First Search on grid</li>

<li>Maximal Flow - Dinic algorithm</li>

<li>Maximal Matching - Hopcroft-Karp algorithm</li>

<li>Minimal Spanning Tree - Kruskal algorithm</li>

<li>Strongly Connected Components</li>

<li>Shortest Paths - Bellman-Ford algorithm</li>
<li>Shortest Paths - Dijkstra algorithm</li>
<li>Shortest Paths - Floyd-Warshall algorithm</li>

<li>Topological sort using DFS</li>
<li>Topological sort using elimination</li>
</ol>

###Sorting algorithms

###Numerical algorithms

###Text algorithms

###Cryptographic algorithms

###Dynamic approach algorithms

###Computentional geometry 

###Data structures

###Libraries

In progress:
===========

###Graph algorithms
<ol>
<li>Articulation points and bridges</li>
<li>Eulerian traversal</li>
<li>Hamiltonian traversal</li>
<li>Traveling Salesman Problem</li>
<li>Minimal Spanning Tree - Prim algorithm</li>
<li>Lowest Common Ancestor - Trajan algorithm</li>
<li>Some connectivity algos</li>
</ol>

###Sorting algorithms

<ol>
<li>HeapSort</li>
<li>MergeSort</li>
<li>QuickSort</li>
<li>InsertionSort</li>
<li>SelectSort</li>
<li>BubbleSort</li>
</ol>

###Numerical algorithms

<ol>
<li>Basic Euclidean algorithm</li>
<li>Extended Euclidean algorithm - diofantic equations</li>
<li>Factorisation</li>
<li>Modular Inverse</li>

<li>Basic Sieve of Eratosthenes</li>
<li>Segmented Sieve of Eratosthenes</li>

<li>Newton's Symbol<li>
<li>Inversion count</li>
<li>Sign of permutation</li>

<li>Basic Sieve of Eratosthenes</li>
<li>Basic Sieve of Eratosthenes</li>

<li>Some generation algorithms (including De Brujin's sequences)<li>

</ol>

###Text algorithms

<ol>
<li>KMP</li>
<li>Manacher</li>
<li>KMP 2D</li>
<li>Cyclic equality</li>
</ol>

###Cryptographic algorithms

<ol>
<li>Basic Caesar</li>
<li>Playfair</li>
<li>Vigenere</li>
</ol>

###Dynamic approach algorithms

<ol>

<li>0-1 Knapsack Problem</li>
<li>Bounded Knapsack Problem</li>
<li>Unbounded Knapsack Problem</li>

<li></li>
<li>Binary Search Tree</li>
<li>Binary Search Tree</li>
<li>Binary Search Tree</li>
<li>Binary Search Tree</li>
<li>Binary Search Tree</li>
<li>Binary Search Tree</li>
<li>Binary Search Tree</li>
<li>Binary Search Tree</li>
<li>Binary Search Tree</li>


</ol>

###Computentional geometry 

<ol>
<li>Hell lot of things</li>
</ol>

###Data structures

<ol>

<li>Static list</li>
<li>Static queue</li>
<li>Static stack</li>
<li>Static heap</li>
<li>Static tree</li>

<li>Dynamic list</li>
<li>Dynamic queue</li>
<li>Dynamic stack</li>
<li>Dynamic heap</li>
<li>Dynamic tree</li>

<li>Binary Search Tree</li>
<li>Red-Black Tree</li>
<li>AVL Tree</li>

<li>Dictionary Tree</li>
<li>Segment Tree</li>
<li>Binary Indexed Tree</li>
<li>Statistic Tree</li>

<li>Disjoint Set Forest 
</ol>

###Libraries

<ol>

<li>BigNums</li>
<li>Matrix</li>
<li>Complex Numbers</li>
<li>Fractions</li>

</ol>
